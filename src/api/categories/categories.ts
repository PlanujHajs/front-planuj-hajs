/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CategoryCreate,
  CategoryModel,
  CategoryOut,
  DeletedModelOut,
  HTTPValidationError
} from '.././types';

import { axiosCustom } from '.././mutator/axiosCustom';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get All CategoryModel from the collection
 * @summary Get All CategoryModel from the collection
 */
export const routeCategoriesGet = (
    
 options?: SecondParameter<typeof axiosCustom>,signal?: AbortSignal
) => {
      
      
      return axiosCustom<CategoryOut[]>(
      {url: `/categories/`, method: 'GET', signal
    },
      options);
    }
  

export const getRouteCategoriesGetQueryKey = () => {
    return [`/categories/`] as const;
    }

    
export const getRouteCategoriesGetQueryOptions = <TData = Awaited<ReturnType<typeof routeCategoriesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRouteCategoriesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof routeCategoriesGet>>> = ({ signal }) => routeCategoriesGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RouteCategoriesGetQueryResult = NonNullable<Awaited<ReturnType<typeof routeCategoriesGet>>>
export type RouteCategoriesGetQueryError = unknown


export function useRouteCategoriesGet<TData = Awaited<ReturnType<typeof routeCategoriesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof routeCategoriesGet>>,
          TError,
          Awaited<ReturnType<typeof routeCategoriesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRouteCategoriesGet<TData = Awaited<ReturnType<typeof routeCategoriesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof routeCategoriesGet>>,
          TError,
          Awaited<ReturnType<typeof routeCategoriesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRouteCategoriesGet<TData = Awaited<ReturnType<typeof routeCategoriesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get All CategoryModel from the collection
 */

export function useRouteCategoriesGet<TData = Awaited<ReturnType<typeof routeCategoriesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRouteCategoriesGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create Category
 */
export const createCategoryCategoriesPost = (
    categoryCreate: CategoryCreate,
 options?: SecondParameter<typeof axiosCustom>,signal?: AbortSignal
) => {
      
      
      return axiosCustom<CategoryOut>(
      {url: `/categories/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: categoryCreate, signal
    },
      options);
    }
  


export const getCreateCategoryCategoriesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategoryCategoriesPost>>, TError,{data: CategoryCreate}, TContext>, request?: SecondParameter<typeof axiosCustom>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategoryCategoriesPost>>, TError,{data: CategoryCreate}, TContext> => {

const mutationKey = ['createCategoryCategoriesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategoryCategoriesPost>>, {data: CategoryCreate}> = (props) => {
          const {data} = props ?? {};

          return  createCategoryCategoriesPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryCategoriesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCategoryCategoriesPost>>>
    export type CreateCategoryCategoriesPostMutationBody = CategoryCreate
    export type CreateCategoryCategoriesPostMutationError = HTTPValidationError

    /**
 * @summary Create Category
 */
export const useCreateCategoryCategoriesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategoryCategoriesPost>>, TError,{data: CategoryCreate}, TContext>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCategoryCategoriesPost>>,
        TError,
        {data: CategoryCreate},
        TContext
      > => {

      const mutationOptions = getCreateCategoryCategoriesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Get One CategoryModel by {id} from the collection
 * @summary Get One CategoryModel by {id} from the collection
 */
export const routeCategoriesIdGet = (
    id: string,
 options?: SecondParameter<typeof axiosCustom>,signal?: AbortSignal
) => {
      
      
      return axiosCustom<CategoryOut>(
      {url: `/categories/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getRouteCategoriesIdGetQueryKey = (id: string,) => {
    return [`/categories/${id}`] as const;
    }

    
export const getRouteCategoriesIdGetQueryOptions = <TData = Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRouteCategoriesIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof routeCategoriesIdGet>>> = ({ signal }) => routeCategoriesIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RouteCategoriesIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof routeCategoriesIdGet>>>
export type RouteCategoriesIdGetQueryError = HTTPValidationError


export function useRouteCategoriesIdGet<TData = Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof routeCategoriesIdGet>>,
          TError,
          Awaited<ReturnType<typeof routeCategoriesIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRouteCategoriesIdGet<TData = Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof routeCategoriesIdGet>>,
          TError,
          Awaited<ReturnType<typeof routeCategoriesIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRouteCategoriesIdGet<TData = Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get One CategoryModel by {id} from the collection
 */

export function useRouteCategoriesIdGet<TData = Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof routeCategoriesIdGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRouteCategoriesIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update One CategoryModel by {id} in the collection
 * @summary Update One CategoryModel by {id} in the collection
 */
export const routeCategoriesIdPatch = (
    id: string,
    categoryModel: CategoryModel,
 options?: SecondParameter<typeof axiosCustom>,) => {
      
      
      return axiosCustom<CategoryOut>(
      {url: `/categories/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: categoryModel
    },
      options);
    }
  


export const getRouteCategoriesIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdPatch>>, TError,{id: string;data: CategoryModel}, TContext>, request?: SecondParameter<typeof axiosCustom>}
): UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdPatch>>, TError,{id: string;data: CategoryModel}, TContext> => {

const mutationKey = ['routeCategoriesIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof routeCategoriesIdPatch>>, {id: string;data: CategoryModel}> = (props) => {
          const {id,data} = props ?? {};

          return  routeCategoriesIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RouteCategoriesIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof routeCategoriesIdPatch>>>
    export type RouteCategoriesIdPatchMutationBody = CategoryModel
    export type RouteCategoriesIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update One CategoryModel by {id} in the collection
 */
export const useRouteCategoriesIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdPatch>>, TError,{id: string;data: CategoryModel}, TContext>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof routeCategoriesIdPatch>>,
        TError,
        {id: string;data: CategoryModel},
        TContext
      > => {

      const mutationOptions = getRouteCategoriesIdPatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Replace One CategoryModel by {id} in the collection
 * @summary Replace One CategoryModel by {id} in the collection
 */
export const routeCategoriesIdPut = (
    id: string,
    categoryModel: CategoryModel,
 options?: SecondParameter<typeof axiosCustom>,) => {
      
      
      return axiosCustom<CategoryOut>(
      {url: `/categories/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: categoryModel
    },
      options);
    }
  


export const getRouteCategoriesIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdPut>>, TError,{id: string;data: CategoryModel}, TContext>, request?: SecondParameter<typeof axiosCustom>}
): UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdPut>>, TError,{id: string;data: CategoryModel}, TContext> => {

const mutationKey = ['routeCategoriesIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof routeCategoriesIdPut>>, {id: string;data: CategoryModel}> = (props) => {
          const {id,data} = props ?? {};

          return  routeCategoriesIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RouteCategoriesIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof routeCategoriesIdPut>>>
    export type RouteCategoriesIdPutMutationBody = CategoryModel
    export type RouteCategoriesIdPutMutationError = HTTPValidationError

    /**
 * @summary Replace One CategoryModel by {id} in the collection
 */
export const useRouteCategoriesIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdPut>>, TError,{id: string;data: CategoryModel}, TContext>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof routeCategoriesIdPut>>,
        TError,
        {id: string;data: CategoryModel},
        TContext
      > => {

      const mutationOptions = getRouteCategoriesIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Delete One CategoryModel by {id} from the collection
 * @summary Delete One CategoryModel by {id} from the collection
 */
export const routeCategoriesIdDelete = (
    id: string,
 options?: SecondParameter<typeof axiosCustom>,) => {
      
      
      return axiosCustom<DeletedModelOut>(
      {url: `/categories/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getRouteCategoriesIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosCustom>}
): UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['routeCategoriesIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof routeCategoriesIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  routeCategoriesIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RouteCategoriesIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof routeCategoriesIdDelete>>>
    
    export type RouteCategoriesIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete One CategoryModel by {id} from the collection
 */
export const useRouteCategoriesIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeCategoriesIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof routeCategoriesIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getRouteCategoriesIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    