/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeletedModelOut,
  ExpenseCreate,
  ExpenseModel,
  ExpenseOut,
  HTTPValidationError,
  ListExpensesExpensesGetParams
} from '.././types';

import { axiosCustom } from '.././mutator/axiosCustom';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Update One ExpenseModel by {id} in the collection
 * @summary Update One ExpenseModel by {id} in the collection
 */
export const routeExpensesIdPatch = (
    id: string,
    expenseModel: ExpenseModel,
 options?: SecondParameter<typeof axiosCustom>,) => {
      
      
      return axiosCustom<ExpenseOut>(
      {url: `/expenses/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: expenseModel
    },
      options);
    }
  


export const getRouteExpensesIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdPatch>>, TError,{id: string;data: ExpenseModel}, TContext>, request?: SecondParameter<typeof axiosCustom>}
): UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdPatch>>, TError,{id: string;data: ExpenseModel}, TContext> => {

const mutationKey = ['routeExpensesIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof routeExpensesIdPatch>>, {id: string;data: ExpenseModel}> = (props) => {
          const {id,data} = props ?? {};

          return  routeExpensesIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RouteExpensesIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof routeExpensesIdPatch>>>
    export type RouteExpensesIdPatchMutationBody = ExpenseModel
    export type RouteExpensesIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update One ExpenseModel by {id} in the collection
 */
export const useRouteExpensesIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdPatch>>, TError,{id: string;data: ExpenseModel}, TContext>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof routeExpensesIdPatch>>,
        TError,
        {id: string;data: ExpenseModel},
        TContext
      > => {

      const mutationOptions = getRouteExpensesIdPatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Replace One ExpenseModel by {id} in the collection
 * @summary Replace One ExpenseModel by {id} in the collection
 */
export const routeExpensesIdPut = (
    id: string,
    expenseModel: ExpenseModel,
 options?: SecondParameter<typeof axiosCustom>,) => {
      
      
      return axiosCustom<ExpenseOut>(
      {url: `/expenses/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: expenseModel
    },
      options);
    }
  


export const getRouteExpensesIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdPut>>, TError,{id: string;data: ExpenseModel}, TContext>, request?: SecondParameter<typeof axiosCustom>}
): UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdPut>>, TError,{id: string;data: ExpenseModel}, TContext> => {

const mutationKey = ['routeExpensesIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof routeExpensesIdPut>>, {id: string;data: ExpenseModel}> = (props) => {
          const {id,data} = props ?? {};

          return  routeExpensesIdPut(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RouteExpensesIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof routeExpensesIdPut>>>
    export type RouteExpensesIdPutMutationBody = ExpenseModel
    export type RouteExpensesIdPutMutationError = HTTPValidationError

    /**
 * @summary Replace One ExpenseModel by {id} in the collection
 */
export const useRouteExpensesIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdPut>>, TError,{id: string;data: ExpenseModel}, TContext>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof routeExpensesIdPut>>,
        TError,
        {id: string;data: ExpenseModel},
        TContext
      > => {

      const mutationOptions = getRouteExpensesIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Delete One ExpenseModel by {id} from the collection
 * @summary Delete One ExpenseModel by {id} from the collection
 */
export const routeExpensesIdDelete = (
    id: string,
 options?: SecondParameter<typeof axiosCustom>,) => {
      
      
      return axiosCustom<DeletedModelOut>(
      {url: `/expenses/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getRouteExpensesIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosCustom>}
): UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['routeExpensesIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof routeExpensesIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  routeExpensesIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RouteExpensesIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof routeExpensesIdDelete>>>
    
    export type RouteExpensesIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete One ExpenseModel by {id} from the collection
 */
export const useRouteExpensesIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof routeExpensesIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof routeExpensesIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getRouteExpensesIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Create Expense
 */
export const createExpenseExpensesPost = (
    expenseCreate: ExpenseCreate,
 options?: SecondParameter<typeof axiosCustom>,signal?: AbortSignal
) => {
      
      
      return axiosCustom<ExpenseOut>(
      {url: `/expenses/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: expenseCreate, signal
    },
      options);
    }
  


export const getCreateExpenseExpensesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExpenseExpensesPost>>, TError,{data: ExpenseCreate}, TContext>, request?: SecondParameter<typeof axiosCustom>}
): UseMutationOptions<Awaited<ReturnType<typeof createExpenseExpensesPost>>, TError,{data: ExpenseCreate}, TContext> => {

const mutationKey = ['createExpenseExpensesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createExpenseExpensesPost>>, {data: ExpenseCreate}> = (props) => {
          const {data} = props ?? {};

          return  createExpenseExpensesPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateExpenseExpensesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createExpenseExpensesPost>>>
    export type CreateExpenseExpensesPostMutationBody = ExpenseCreate
    export type CreateExpenseExpensesPostMutationError = HTTPValidationError

    /**
 * @summary Create Expense
 */
export const useCreateExpenseExpensesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExpenseExpensesPost>>, TError,{data: ExpenseCreate}, TContext>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createExpenseExpensesPost>>,
        TError,
        {data: ExpenseCreate},
        TContext
      > => {

      const mutationOptions = getCreateExpenseExpensesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary List Expenses
 */
export const listExpensesExpensesGet = (
    params?: ListExpensesExpensesGetParams,
 options?: SecondParameter<typeof axiosCustom>,signal?: AbortSignal
) => {
      
      
      return axiosCustom<ExpenseOut[]>(
      {url: `/expenses/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListExpensesExpensesGetQueryKey = (params?: ListExpensesExpensesGetParams,) => {
    return [`/expenses/`, ...(params ? [params]: [])] as const;
    }

    
export const getListExpensesExpensesGetQueryOptions = <TData = Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError = HTTPValidationError>(params?: ListExpensesExpensesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListExpensesExpensesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listExpensesExpensesGet>>> = ({ signal }) => listExpensesExpensesGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListExpensesExpensesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listExpensesExpensesGet>>>
export type ListExpensesExpensesGetQueryError = HTTPValidationError


export function useListExpensesExpensesGet<TData = Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError = HTTPValidationError>(
 params: undefined |  ListExpensesExpensesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listExpensesExpensesGet>>,
          TError,
          Awaited<ReturnType<typeof listExpensesExpensesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListExpensesExpensesGet<TData = Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError = HTTPValidationError>(
 params?: ListExpensesExpensesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listExpensesExpensesGet>>,
          TError,
          Awaited<ReturnType<typeof listExpensesExpensesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListExpensesExpensesGet<TData = Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError = HTTPValidationError>(
 params?: ListExpensesExpensesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Expenses
 */

export function useListExpensesExpensesGet<TData = Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError = HTTPValidationError>(
 params?: ListExpensesExpensesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listExpensesExpensesGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListExpensesExpensesGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Expense
 */
export const getExpenseExpensesExpenseIdGet = (
    expenseId: string,
 options?: SecondParameter<typeof axiosCustom>,signal?: AbortSignal
) => {
      
      
      return axiosCustom<ExpenseOut>(
      {url: `/expenses/${expenseId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetExpenseExpensesExpenseIdGetQueryKey = (expenseId: string,) => {
    return [`/expenses/${expenseId}`] as const;
    }

    
export const getGetExpenseExpensesExpenseIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError = HTTPValidationError>(expenseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExpenseExpensesExpenseIdGetQueryKey(expenseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>> = ({ signal }) => getExpenseExpensesExpenseIdGet(expenseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(expenseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExpenseExpensesExpenseIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>>
export type GetExpenseExpensesExpenseIdGetQueryError = HTTPValidationError


export function useGetExpenseExpensesExpenseIdGet<TData = Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError = HTTPValidationError>(
 expenseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>,
          TError,
          Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpenseExpensesExpenseIdGet<TData = Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError = HTTPValidationError>(
 expenseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>,
          TError,
          Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExpenseExpensesExpenseIdGet<TData = Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError = HTTPValidationError>(
 expenseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Expense
 */

export function useGetExpenseExpensesExpenseIdGet<TData = Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError = HTTPValidationError>(
 expenseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenseExpensesExpenseIdGet>>, TError, TData>>, request?: SecondParameter<typeof axiosCustom>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExpenseExpensesExpenseIdGetQueryOptions(expenseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



